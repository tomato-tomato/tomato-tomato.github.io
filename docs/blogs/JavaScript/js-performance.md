---
title: Javascript 性能优化
date: 2021-01-26
sidebar: 'auto'
categories:
 - JavaScript
tags:
 - JavaScript
publish: true
isShowComments: true
---

## JavaScript 内存管理

- 内存： 由可读写单元组成，表示一片可操作空间
- 管理： 人为的去操作空间的申请，使用 和 释放
- 内存管理： 开发者主动申请空间，使用空间，释放空间
- 管理流程： 申请 —— 使用 —— 释放



## JavaScript中的垃圾 

- JavaScript 中内存管理是自动的

- 对象不再被引用时是垃圾
- 对象不能从根上访问到时是垃圾



## JavaScript 中的可达对象

- 可以访问到的对象就是可达对象 （引用、作用域链）
- 可达的标准就是从根触发是否可以被找到
- JavaScript 中的根可以理解为时全局变量对象



### JavaScript 中的引用 和 可达

```js
let obj = {name: 'tom'} // 该对象空间被 obj 引用，且obj 可以从全局中找到即 可达，也间接指出该对象空间 也是可达的

let tom = obj; // 对象空间又多了一次被 tom 的引用

obj = null; // obj 对于对象空间的引用切断，由于tom还在对对象空间产生引用，即对象空间还是可达的
```



```js
function objGroup(obj1, obj2){
    obj1.next = obj2;
    obj2.prev = obj1;
    
    return {
        o1: obj1,
        o2: obj2
    }
}

let obj = objGroup({name: 'obj1'}, {name: 'obj2'})
delete obj.o1;
console.log(obj);
```



## GC

### GC中的垃圾是什么

- 程序中不再需要使用的对象
- 程序中不能再访问到的对象



### GC算法

GC工作时查找和回收所遵循的规则。

- 引用计数
- 标记清除
- 标记整理
- 分代回收



###  引用计数算法

- 核心实现： 设置引用数，判断当前引用数是否为 0 
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为 0 时立即回收

#### 引用计数优点

- 发现垃圾立即回收
- 最大限度的减少程序暂停

#### 引用计数缺点

- 无法回收循环引用的对象
- 时间开销大



### 标记清除算法

- 核心思想： 分 标记 和 清除两个阶段
- 遍历所有对象标记活动对象（对可达对象的标记）
- 遍历所有对象清除没有标记对象
- 回收相应的空间（需要回收的空间会放在空闲列表里面）



#### 标记清除优点

- 对于引用计数算法可回收循环引用的对象

#### 标记清除缺点

- 可能造成地址不连续的碎片化空间（回收的空间不连续）
- 不会立即回收垃圾对象



### 标记整理算法

- 标记整理可以看作时标记清除的增强

- 标记阶段的和标记清除的操作都是一致的
- 清除阶段会先执行整理，移动对象位置

#### 标记整理优点

- 减少碎片化空间

#### 标记整理缺点

- 不会立即回收垃圾对象



## 认识V8

- V8 是一款主流的 JavaScript 执行引擎
- V8 采用即时编译
- V8 内存设限 64位 1.5G 32位 800M
  - 对于浏览器使用已经足够
  - 对于垃圾回收机制内存太大反而耗时间

### V8 垃圾回收策略

回收主要是针对当前存在 堆区 里面的对象数据。

- 采用分代回收的思想
- 内存分为 新生代、老生代
- 针对不同对象采用不同回收算法操作



### V8 中常用的 GC算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量



### V8 回收新生代对象

- V8 内存空间一分为二，分代回收
- 小空间用于存储新生代对象 （64位：32M ，32位：16M）
- 新生代对象指的是存活时间较短的对象



- 回收过程采用 复制算法 + 标记整理
- 新生代内存去分为两个等大空间
- 使用空间为 From， 空闲空间为 To
- 活动对象存储于 From 空间
- 标记整理后将活动对象拷贝至 To
- From 与 To 交换空间完成释放



- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动到老生代
  - 当一轮 GC 后还存活的新生代需要晋升
  - To 空间使用率超过 25% 也会晋升



### V8 回收老生代对象

- 老生代 空间 64位：1.4G，32位：700M
- 老生代对象就是指存活时间较长的对象



- 主要采用 标记清除、标记整理、增量标记算法
- 首先使用标记清除完成垃圾空间回收
- 当新生代有对象要晋升，老生代空间欠缺，则采用标记整理进行空间优化
- 采用增量标记进行效率优化
  - 垃圾回收会让JavaScript执行进程阻塞
  - 增量标记值将一整块的垃圾回收操作拆分成小块
  - 让垃圾回收跟执行交替进行 从而提升效率



### 新生代老生代对比

- 新生代区域垃圾回收使用空间换时间，由于新生代空间本身就很小，空间也花费不多相对于节约的时间比较划算





## Performance 工具

GC 的目的是为了实现内存空间的良性循环



### 界定内存问题的标准

- 内存泄漏： 内存使用持续升高
- 内存膨胀： 多数设备上存在性能问题
- 频繁垃圾回收： 通过内存变化图进行分析



### 监控内存的几种方式

- 浏览器任务管理器
- Timeline 时序图记录
- 堆快照查找分离 DOM
- 判断是否存在频繁的垃圾回收



### 堆快照查找分离DOM

#### 什么是分离DOM

- 垃圾对象的DOM节点
  - 节点从当前DOM树上脱离，在js中没引用
- 分离状态的DOM节点
  - 节点从当前DOM树上脱离，但存在引用。页面无法看到，在内存中占据着空间



### 频繁的GC操作造成的影响

- GC工作时应用程序时停止的
- 频繁且过长时间的GC操作会导致应用假死
- 用户使用中有卡顿



## 代码优化

- 慎用全局变量
  - 全局变量定义在全局执行上下文，是所有作用域链的顶端，查找的时间长
  - 全局执行上下文一致存在于上下文执行栈，直到程序退出。影响GC的运行，降低对内存的使用
  - 某个局部作用域出现同名变量这回遮蔽或污染该全局变量

- 缓存局部变量

- 通过原型对象添加附加方法
- 避开闭包陷阱
  - 闭包使用不当容易造成内存泄漏
  - 不要为了闭包而闭包
- For循环优化
- 采用最优的循环方式
  - 对于数组 forEach 更优
- 节点添加优化
  - 节点的添加操作必然会有回流和重绘
  - 利用` document.createDocumentFragment()` 文档碎片添加节点效率更高
- 克隆优化节点操作
  - 利用 节点的 `cloneNode`方法
- 直接量替换 Object 操作


